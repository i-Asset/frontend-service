/**
 * the Info
 * infodescription
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AssetAdministrationShell } from '../model/assetAdministrationShell';
import { ConceptDescription } from '../model/conceptDescription';
import { OperationRequest } from '../model/operationRequest';
import { OperationResult } from '../model/operationResult';
import { Result } from '../model/result';
import { Submodel } from '../model/submodel';
import { SubmodelElement } from '../model/submodelElement';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class AssetAdministrationShellEnvironmentAPIService {

    protected basePath = '{protocol}://{server}:{port}/{path}';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Deletes a Concept Description
     * 
     * @param cdIdentifier The Concept Description’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteConceptDescriptionById(cdIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public deleteConceptDescriptionById(cdIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public deleteConceptDescriptionById(cdIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public deleteConceptDescriptionById(cdIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (cdIdentifier === null || cdIdentifier === undefined) {
            throw new Error('Required parameter cdIdentifier was null or undefined when calling deleteConceptDescriptionById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Result>('delete',`${this.basePath}/concept-descriptions/${encodeURIComponent(String(cdIdentifier))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a Submodel
     * 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteSubmodelById(submodelIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public deleteSubmodelById(submodelIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public deleteSubmodelById(submodelIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public deleteSubmodelById(submodelIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Result>('delete',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a submodel element at a specified path within the submodel elements hierarchy
     * 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelElementByPathSubmodelRepo.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling deleteSubmodelElementByPathSubmodelRepo.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Result>('delete',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements/${encodeURIComponent(String(idShortPath))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all Concept Descriptions
     * 
     * @param idShort The Concept Description’s IdShort
     * @param isCaseOf IsCaseOf reference (UTF8-BASE64-URL-encoded)
     * @param dataSpecificationRef DataSpecification reference (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllConceptDescriptions(idShort?: string, isCaseOf?: string, dataSpecificationRef?: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public getAllConceptDescriptions(idShort?: string, isCaseOf?: string, dataSpecificationRef?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public getAllConceptDescriptions(idShort?: string, isCaseOf?: string, dataSpecificationRef?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public getAllConceptDescriptions(idShort?: string, isCaseOf?: string, dataSpecificationRef?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (idShort !== undefined && idShort !== null) {
            queryParameters = queryParameters.set('idShort', <any>idShort);
        }
        if (isCaseOf !== undefined && isCaseOf !== null) {
            queryParameters = queryParameters.set('isCaseOf', <any>isCaseOf);
        }
        if (dataSpecificationRef !== undefined && dataSpecificationRef !== null) {
            queryParameters = queryParameters.set('dataSpecificationRef', <any>dataSpecificationRef);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Result>('get',`${this.basePath}/concept-descriptions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all submodel elements including their hierarchy
     * 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllSubmodelElementsSubmodelRepo(submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<SubmodelElement>>;
    public getAllSubmodelElementsSubmodelRepo(submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SubmodelElement>>>;
    public getAllSubmodelElementsSubmodelRepo(submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SubmodelElement>>>;
    public getAllSubmodelElementsSubmodelRepo(submodelIdentifier: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsSubmodelRepo.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<SubmodelElement>>('get',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all Submodels
     * 
     * @param semanticId The value of the semantic id reference (BASE64-URL-encoded)
     * @param idShort The Submodel’s idShort
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllSubmodels(semanticId?: string, idShort?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Submodel>>;
    public getAllSubmodels(semanticId?: string, idShort?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Submodel>>>;
    public getAllSubmodels(semanticId?: string, idShort?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Submodel>>>;
    public getAllSubmodels(semanticId?: string, idShort?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (semanticId !== undefined && semanticId !== null) {
            queryParameters = queryParameters.set('semanticId', <any>semanticId);
        }
        if (idShort !== undefined && idShort !== null) {
            queryParameters = queryParameters.set('idShort', <any>idShort);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Submodel>>('get',`${this.basePath}/submodels`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a specific Asset Administration Shell
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAssetAdministrationShellById(aasIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<AssetAdministrationShell>;
    public getAssetAdministrationShellById(aasIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AssetAdministrationShell>>;
    public getAssetAdministrationShellById(aasIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AssetAdministrationShell>>;
    public getAssetAdministrationShellById(aasIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling getAssetAdministrationShellById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AssetAdministrationShell>('get',`${this.basePath}/old/${encodeURIComponent(String(aasIdentifier))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a specific Concept Description
     * 
     * @param cdIdentifier The Concept Description’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getConceptDescriptionById(cdIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<ConceptDescription>;
    public getConceptDescriptionById(cdIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConceptDescription>>;
    public getConceptDescriptionById(cdIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConceptDescription>>;
    public getConceptDescriptionById(cdIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (cdIdentifier === null || cdIdentifier === undefined) {
            throw new Error('Required parameter cdIdentifier was null or undefined when calling getConceptDescriptionById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<ConceptDescription>('get',`${this.basePath}/concept-descriptions/${encodeURIComponent(String(cdIdentifier))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Downloads file content from a specific submodel element from the Submodel at a specified path
     * 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getFileByPathSubmodelRepo.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling getFileByPathSubmodelRepo.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Blob>('get',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements/${encodeURIComponent(String(idShortPath))}/attachment`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the Operation result of an asynchronous invoked Operation
     * 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated), in this case an operation
     * @param handleId The returned handle id of an operation’s asynchronous invocation used to request the current state of the operation’s execution (UTF8-BASE64-URL-encoded)
     * @param content 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOperationAsyncResultSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, content?: string, observe?: 'body', reportProgress?: boolean): Observable<OperationResult>;
    public getOperationAsyncResultSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, content?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OperationResult>>;
    public getOperationAsyncResultSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, content?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OperationResult>>;
    public getOperationAsyncResultSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, content?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncResultSubmodelRepo.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling getOperationAsyncResultSubmodelRepo.');
        }

        if (handleId === null || handleId === undefined) {
            throw new Error('Required parameter handleId was null or undefined when calling getOperationAsyncResultSubmodelRepo.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<OperationResult>('get',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements/${encodeURIComponent(String(idShortPath))}/operation-results/${encodeURIComponent(String(handleId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a specific Submodel
     * 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSubmodelById(submodelIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<Submodel>;
    public getSubmodelById(submodelIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Submodel>>;
    public getSubmodelById(submodelIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Submodel>>;
    public getSubmodelById(submodelIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getSubmodelById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Submodel>('get',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a specific submodel element from the Submodel at a specified path
     * 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public getSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public getSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public getSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathSubmodelRepo.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathSubmodelRepo.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Result>('get',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements/${encodeURIComponent(String(idShortPath))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Synchronously or asynchronously invokes an Operation at a specified path
     * 
     * @param body 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated), in this case an operation
     * @param async Determines whether an operation invocation is performed asynchronously or synchronously
     * @param content Determines the request or response kind of the resource
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public invokeOperationSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, async?: string, content?: string, observe?: 'body', reportProgress?: boolean): Observable<OperationResult>;
    public invokeOperationSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, async?: string, content?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OperationResult>>;
    public invokeOperationSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, async?: string, content?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OperationResult>>;
    public invokeOperationSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, async?: string, content?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling invokeOperationSubmodelRepo.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling invokeOperationSubmodelRepo.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling invokeOperationSubmodelRepo.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (async !== undefined && async !== null) {
            queryParameters = queryParameters.set('async', <any>async);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<OperationResult>('post',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements/${encodeURIComponent(String(idShortPath))}/invoke`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new Concept Description
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postConceptDescription(body: ConceptDescription, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public postConceptDescription(body: ConceptDescription, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public postConceptDescription(body: ConceptDescription, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public postConceptDescription(body: ConceptDescription, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postConceptDescription.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('post',`${this.basePath}/concept-descriptions`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new Submodel
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postSubmodel(body: Submodel, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public postSubmodel(body: Submodel, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public postSubmodel(body: Submodel, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public postSubmodel(body: Submodel, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postSubmodel.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('post',`${this.basePath}/submodels`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new submodel element at a specified path within submodel elements hierarchy
     * 
     * @param body 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public postSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public postSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public postSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postSubmodelElementByPathSubmodelRepo.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling postSubmodelElementByPathSubmodelRepo.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling postSubmodelElementByPathSubmodelRepo.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('post',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements/${encodeURIComponent(String(idShortPath))}`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new submodel element
     * 
     * @param body 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postSubmodelElementSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public postSubmodelElementSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public postSubmodelElementSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public postSubmodelElementSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postSubmodelElementSubmodelRepo.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling postSubmodelElementSubmodelRepo.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('post',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing Concept Description
     * 
     * @param body 
     * @param cdIdentifier The Concept Description’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putConceptDescriptionById(body: ConceptDescription, cdIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public putConceptDescriptionById(body: ConceptDescription, cdIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public putConceptDescriptionById(body: ConceptDescription, cdIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public putConceptDescriptionById(body: ConceptDescription, cdIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putConceptDescriptionById.');
        }

        if (cdIdentifier === null || cdIdentifier === undefined) {
            throw new Error('Required parameter cdIdentifier was null or undefined when calling putConceptDescriptionById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('put',`${this.basePath}/concept-descriptions/${encodeURIComponent(String(cdIdentifier))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
     * 
     * @param fileName 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param file 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putFileByPathSubmodelRepoForm(fileName: string, submodelIdentifier: string, idShortPath: string, file?: Blob, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public putFileByPathSubmodelRepoForm(fileName: string, submodelIdentifier: string, idShortPath: string, file?: Blob, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public putFileByPathSubmodelRepoForm(fileName: string, submodelIdentifier: string, idShortPath: string, file?: Blob, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public putFileByPathSubmodelRepoForm(fileName: string, submodelIdentifier: string, idShortPath: string, file?: Blob, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling putFileByPathSubmodelRepo.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling putFileByPathSubmodelRepo.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling putFileByPathSubmodelRepo.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fileName !== undefined && fileName !== null) {
            queryParameters = queryParameters.set('fileName', <any>fileName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (file !== undefined) {
            formParams = formParams.append('file', <any>file) as any || formParams;
        }

        return this.httpClient.request<Result>('put',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements/${encodeURIComponent(String(idShortPath))}/attachment`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing Submodel
     * 
     * @param body 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putSubmodelById(body: Submodel, submodelIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public putSubmodelById(body: Submodel, submodelIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public putSubmodelById(body: Submodel, submodelIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public putSubmodelById(body: Submodel, submodelIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putSubmodelById.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling putSubmodelById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('put',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing submodel element at a specified path within submodel elements hierarchy
     * 
     * @param body 
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public putSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public putSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public putSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putSubmodelElementByPathSubmodelRepo.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling putSubmodelElementByPathSubmodelRepo.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling putSubmodelElementByPathSubmodelRepo.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('put',`${this.basePath}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel-elements/${encodeURIComponent(String(idShortPath))}`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
