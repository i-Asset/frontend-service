/**
 * the Info
 * infodescription
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { AssetAdministrationShell } from '../model/assetAdministrationShell';
import { AssetInformation } from '../model/assetInformation';
import { OperationRequest } from '../model/operationRequest';
import { OperationResult } from '../model/operationResult';
import { Reference } from '../model/reference';
import { Result } from '../model/result';
import { SpecificAssetId } from '../model/specificAssetId';
import { Submodel } from '../model/submodel';
import { SubmodelElement } from '../model/submodelElement';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class AssetAdministrationShellRepositoryInterfaceSPECService {

    protected basePath = '{protocol}://{server}:{port}/{path}';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Deletes an Asset Administration Shell
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteAssetAdministrationShellById(aasIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteAssetAdministrationShellById(aasIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteAssetAdministrationShellById(aasIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteAssetAdministrationShellById(aasIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling deleteAssetAdministrationShellById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a submodel element at a specified path within the submodel elements hierarchy
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteSubmodelElementByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteSubmodelElementByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteSubmodelElementByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteSubmodelElementByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling deleteSubmodelElementByPath.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelElementByPath.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling deleteSubmodelElementByPath.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements/${encodeURIComponent(String(idShortPath))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes the submodel reference from the Asset Administration Shell
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteSubmodelReferenceById(aasIdentifier: string, submodelIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteSubmodelReferenceById(aasIdentifier: string, submodelIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteSubmodelReferenceById(aasIdentifier: string, submodelIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteSubmodelReferenceById(aasIdentifier: string, submodelIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling deleteSubmodelReferenceById.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelReferenceById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all Asset Administration Shells
     * 
     * @param assetIds A list of specific Asset identifiers
     * @param idShort The Asset Administration Shell’s IdShort
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllAssetAdministrationShells(assetIds?: Array<SpecificAssetId>, idShort?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AssetAdministrationShell>>;
    public getAllAssetAdministrationShells(assetIds?: Array<SpecificAssetId>, idShort?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AssetAdministrationShell>>>;
    public getAllAssetAdministrationShells(assetIds?: Array<SpecificAssetId>, idShort?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AssetAdministrationShell>>>;
    public getAllAssetAdministrationShells(assetIds?: Array<SpecificAssetId>, idShort?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (assetIds) {
            assetIds.forEach((element) => {
                queryParameters = queryParameters.append('assetIds', <any>element);
            })
        }
        if (idShort !== undefined && idShort !== null) {
            queryParameters = queryParameters.set('idShort', <any>idShort);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<AssetAdministrationShell>>('get',`${this.basePath}/shells`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all submodel elements including their hierarchy
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllSubmodelElements(aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<SubmodelElement>>;
    public getAllSubmodelElements(aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SubmodelElement>>>;
    public getAllSubmodelElements(aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SubmodelElement>>>;
    public getAllSubmodelElements(aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling getAllSubmodelElements.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElements.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<SubmodelElement>>('get',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns all submodel references
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllSubmodelReferences(aasIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Reference>>;
    public getAllSubmodelReferences(aasIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Reference>>>;
    public getAllSubmodelReferences(aasIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Reference>>>;
    public getAllSubmodelReferences(aasIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling getAllSubmodelReferences.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<Reference>>('get',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a specific Asset Administration Shell
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAssetAdministrationShell(aasIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<AssetAdministrationShell>;
    public getAssetAdministrationShell(aasIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AssetAdministrationShell>>;
    public getAssetAdministrationShell(aasIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AssetAdministrationShell>>;
    public getAssetAdministrationShell(aasIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling getAssetAdministrationShell.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AssetAdministrationShell>('get',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the Asset Information
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAssetInformation(aasIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<AssetInformation>;
    public getAssetInformation(aasIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AssetInformation>>;
    public getAssetInformation(aasIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AssetInformation>>;
    public getAssetInformation(aasIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling getAssetInformation.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AssetInformation>('get',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/asset-information`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Downloads file content from a specific submodel element from the Submodel at a specified path
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFileByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;
    public getFileByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;
    public getFileByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;
    public getFileByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling getFileByPath.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getFileByPath.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling getFileByPath.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/octet-stream',
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Blob>('get',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements/${encodeURIComponent(String(idShortPath))}/attachment`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the Operation result of an asynchronous invoked Operation
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated), in this case an operation
     * @param handleId The returned handle id of an operation’s asynchronous invocation used to request the current state of the operation’s execution (UTF8-BASE64-URL-encoded)
     * @param content 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOperationAsyncResult(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, content?: string, observe?: 'body', reportProgress?: boolean): Observable<OperationResult>;
    public getOperationAsyncResult(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, content?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OperationResult>>;
    public getOperationAsyncResult(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, content?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OperationResult>>;
    public getOperationAsyncResult(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, content?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling getOperationAsyncResult.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncResult.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling getOperationAsyncResult.');
        }

        if (handleId === null || handleId === undefined) {
            throw new Error('Required parameter handleId was null or undefined when calling getOperationAsyncResult.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<OperationResult>('get',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements/${encodeURIComponent(String(idShortPath))}/operation-results/${encodeURIComponent(String(handleId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the Submodel
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSubmodel1(aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<Submodel>;
    public getSubmodel1(aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Submodel>>;
    public getSubmodel1(aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Submodel>>;
    public getSubmodel1(aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling getSubmodel1.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getSubmodel1.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Submodel>('get',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a specific submodel element from the Submodel at a specified path
     * 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSubmodelElementByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<SubmodelElement>;
    public getSubmodelElementByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubmodelElement>>;
    public getSubmodelElementByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubmodelElement>>;
    public getSubmodelElementByPath(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling getSubmodelElementByPath.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPath.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling getSubmodelElementByPath.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SubmodelElement>('get',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements/${encodeURIComponent(String(idShortPath))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Synchronously or asynchronously invokes an Operation at a specified path
     * 
     * @param body 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated), in this case an operation
     * @param async Determines whether an operation invocation is performed asynchronously or synchronously
     * @param content Determines the request or response kind of the resource
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public invokeOperation(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, async?: string, content?: string, observe?: 'body', reportProgress?: boolean): Observable<OperationResult>;
    public invokeOperation(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, async?: string, content?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OperationResult>>;
    public invokeOperation(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, async?: string, content?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OperationResult>>;
    public invokeOperation(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, async?: string, content?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling invokeOperation.');
        }

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling invokeOperation.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling invokeOperation.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling invokeOperation.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (async !== undefined && async !== null) {
            queryParameters = queryParameters.set('async', <any>async);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<OperationResult>('post',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements/${encodeURIComponent(String(idShortPath))}/invoke`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new Asset Administration Shell
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postAssetAdministrationShell(body: AssetAdministrationShell, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public postAssetAdministrationShell(body: AssetAdministrationShell, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public postAssetAdministrationShell(body: AssetAdministrationShell, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public postAssetAdministrationShell(body: AssetAdministrationShell, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postAssetAdministrationShell.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('post',`${this.basePath}/shells`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new submodel element
     * 
     * @param body 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postSubmodelElement(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public postSubmodelElement(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public postSubmodelElement(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public postSubmodelElement(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postSubmodelElement.');
        }

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling postSubmodelElement.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling postSubmodelElement.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('post',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new submodel element at a specified path within submodel elements hierarchy
     * 
     * @param body 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postSubmodelElementByPath(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public postSubmodelElementByPath(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public postSubmodelElementByPath(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public postSubmodelElementByPath(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postSubmodelElementByPath.');
        }

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling postSubmodelElementByPath.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling postSubmodelElementByPath.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling postSubmodelElementByPath.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('post',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements/${encodeURIComponent(String(idShortPath))}`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a submodel reference at the Asset Administration Shell
     * 
     * @param body 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postSubmodelReference(body: Reference, aasIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<Reference>;
    public postSubmodelReference(body: Reference, aasIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Reference>>;
    public postSubmodelReference(body: Reference, aasIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Reference>>;
    public postSubmodelReference(body: Reference, aasIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postSubmodelReference.');
        }

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling postSubmodelReference.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Reference>('post',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing Asset Administration Shell
     * 
     * @param body 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putAssetAdministrationShellById(body: AssetAdministrationShell, aasIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public putAssetAdministrationShellById(body: AssetAdministrationShell, aasIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public putAssetAdministrationShellById(body: AssetAdministrationShell, aasIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public putAssetAdministrationShellById(body: AssetAdministrationShell, aasIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putAssetAdministrationShellById.');
        }

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling putAssetAdministrationShellById.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<Result>('put',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the Asset Information
     * 
     * @param body 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putAssetInformation(body: AssetInformation, aasIdentifier: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public putAssetInformation(body: AssetInformation, aasIdentifier: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public putAssetInformation(body: AssetInformation, aasIdentifier: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public putAssetInformation(body: AssetInformation, aasIdentifier: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putAssetInformation.');
        }

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling putAssetInformation.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/asset-information`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
     * 
     * @param fileName 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param file 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putFileByPathForm(fileName: string, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, file?: Blob, observe?: 'body', reportProgress?: boolean): Observable<Result>;
    public putFileByPathForm(fileName: string, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, file?: Blob, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Result>>;
    public putFileByPathForm(fileName: string, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, file?: Blob, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Result>>;
    public putFileByPathForm(fileName: string, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, file?: Blob, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling putFileByPath.');
        }

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling putFileByPath.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling putFileByPath.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling putFileByPath.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fileName !== undefined && fileName !== null) {
            queryParameters = queryParameters.set('fileName', <any>fileName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (file !== undefined) {
            formParams = formParams.append('file', <any>file) as any || formParams;
        }

        return this.httpClient.request<Result>('put',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements/${encodeURIComponent(String(idShortPath))}/attachment`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the Submodel
     * 
     * @param body 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putSubmodel(body: Submodel, aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public putSubmodel(body: Submodel, aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public putSubmodel(body: Submodel, aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public putSubmodel(body: Submodel, aasIdentifier: string, submodelIdentifier: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putSubmodel.');
        }

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling putSubmodel.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling putSubmodel.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing submodel element at a specified path within submodel elements hierarchy
     * 
     * @param body 
     * @param aasIdentifier The Asset Administration Shell’s unique id (UTF8-BASE64-URL-encoded)
     * @param submodelIdentifier The Submodel’s unique id (UTF8-BASE64-URL-encoded)
     * @param idShortPath IdShort path to the submodel element (dot-separated)
     * @param level Determines the structural depth of the respective resource content
     * @param content Determines the request or response kind of the resource
     * @param extent Determines to which extent the resource is being serialized
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putSubmodelElementByPath(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public putSubmodelElementByPath(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public putSubmodelElementByPath(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public putSubmodelElementByPath(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, content?: string, extent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putSubmodelElementByPath.');
        }

        if (aasIdentifier === null || aasIdentifier === undefined) {
            throw new Error('Required parameter aasIdentifier was null or undefined when calling putSubmodelElementByPath.');
        }

        if (submodelIdentifier === null || submodelIdentifier === undefined) {
            throw new Error('Required parameter submodelIdentifier was null or undefined when calling putSubmodelElementByPath.');
        }

        if (idShortPath === null || idShortPath === undefined) {
            throw new Error('Required parameter idShortPath was null or undefined when calling putSubmodelElementByPath.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (level !== undefined && level !== null) {
            queryParameters = queryParameters.set('level', <any>level);
        }
        if (content !== undefined && content !== null) {
            queryParameters = queryParameters.set('content', <any>content);
        }
        if (extent !== undefined && extent !== null) {
            queryParameters = queryParameters.set('extent', <any>extent);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/shells/${encodeURIComponent(String(aasIdentifier))}/submodels/${encodeURIComponent(String(submodelIdentifier))}/submodel/submodel-elements/${encodeURIComponent(String(idShortPath))}`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
